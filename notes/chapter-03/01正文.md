# 正文

## 3.1 历史观点

- K表示1 000  M表示 1 000 000  G表示 1 000 000 000
 
> 8086 第一代单芯片、16位微处理器之一。 8088 是 8086 的一个变种，在8086基础上增加了一个8位外部总线。

> i386 (275k个晶体管)。将体系结构扩展到32位。增加了平坦寻址模式。是Intel系列中第一台全面支持Unix操作系统的机器。

## 3.2 程序编码
假设：一个C程序，有两个文件 p1.c 和 p2.c 。用Unix命令行编译这些代码：
`linux> gcc -Og -o p p1.c p2.c`
(-Og  大写的字母 ‘O’)

*-Og 是告诉编译器使用 会生成 符合原始C代码 整体结构的机器代码的优化等级*

- 抽象1：指令集体系结构或指令集架构(ISA)，定义机器级程序的格式和行为，定义了处理器状态、指令的格式、以及每条指令对状态的影响。
- 抽象2：虚拟地址，是机器级程序使用的内存地址。提供的内存模型看上去是一个非常大的字节数组。

### 3.2.1 机器级代码
- 程序计数器(PC),给出将要执行下一条指令在内存中的地址。
- 整数寄存器文件，包含16个命名的位置，分别存储64位的值。这些寄存器可以存储地址(对应于C语言的指针)或整数数据。有的寄存器被用来记录某些重要的程序状态，其他的寄存器用来保存临时数据。
- 条件码寄存器， 保存最近执行的算术或逻辑指令的状态信息。用来实现控制或数据流中的条件变化，比如if和while语句。
- 一组向量寄存器可以存放一个或多个整数或浮点数值。
- 虽然C语言提供了一种模型，可以在内存中声明和分配各种数据类型的对象。但是机器代码只是简单地将内存看成一个很大的、按字节寻址的数组。
- C语言中的聚合数据类型，例如数组和结构，在机器代码中用一组连续的字节来表示。
- <font color="red">即使对标量数据类型，汇编代码也不区分有符号或无符号整数，不区分各种类型的指针，甚至不区分指针和整数。</font>
*标量类型（Scalar type）是相对复合类型（Compound type）来说的：标量类型只能有一个值，而复合类型可以包含多个值。复合类型是由标量类型构成的。如：int，char，enum，float等*

- 程序内存包括：
    > 可执行机器代码、操作系统需要的一些信息、用来管理过程调用和返回的运行时栈、用户分配的内存块（比如说用malloc库函数分配的）
- 操作系统负责管理虚拟地址空间，将虚拟地址翻译成实际处理器内存中的物理地址。
- 一条机器指令只执行一个非常基本的操作。

### 3.2.2 代码示例

mstore.c
```C
long mult2(long, long);
void multstore(long x, long y, long *dest)
{
    long t = mult2(x, y);
    *dest = t
}
```

- 在命令行使用 “-S” 选项，能看到C语言编译器产生的汇编代码：
`linux> gcc -Og -S mstore.c`

- 使用 “-c” 选项，GCC会编译并汇编该代码：
`linux> gcc -Og -c mstore.c`

```
在文件 mstore.o上运行GDB
linux> gdb multstore.o

输入命令：
(gdb) x/14xb multstore

该命令的含义是，告诉GDB 显示(简写为'x')从函数multstore所处地址开始
的 14 个 十六进制格式表示 (简写为'x')的字节(简写为'b')
```

- 在Linux系统中，带 '-d' 命令行标志的程序 objdump 可以查看机器代码文件，根据机器代码产生一种类似于汇编代码的格式：
`linux> objdump -d mstore.o`

结果如下：
```S
mstore.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <multstore>:
   0:   53                      push   %rbx
   1:   48 89 d3                mov    %rdx,%rbx
   4:   e8 00 00 00 00          callq  9 <multstore+0x9>
   9:   48 89 03                mov    %rax,(%rbx)
   c:   5b                      pop    %rbx
   d:   c3                      retq   
```

- 生成实际可执行的代码需要对一组目标代码文件运行链接器，而这一组目标代码文件中必须含有一个main函数。
```C
  1 #include <stdio.h>
  2 
  3 int main()
  4 {
  5     long d;
  6     multstore(2, 3, &d);
  7     printf("2 * 3 --> %ld\n", d);
  8     return 0;                                                                                                                                           
  9 }   
 10 
 11 long mult2(long a, long b)
 12 {
 13     long s = a * b;
 14     return s;
 15 }   
```

- 用gcc中的 '-o' 指令，生成可执行文件prog：
`linux> gcc -Og -c prog main.c multstore.c`

- 反汇编这个prog文件，会发现这样一段代码：
```
0000000000400570 <multstore>:
  400570:       53                      push   %rbx
  400571:       48 89 d3                mov    %rdx,%rbx
  400574:       e8 ef ff ff ff          callq  400568 <mult2>
  400579:       48 89 03                mov    %rax,(%rbx)
  40057c:       5b                      pop    %rbx
  40057d:       c3                      retq   
  40057e:       66 90                   xchg   %ax,%ax
```

***与mstore.c反汇编产生的代码几乎完全一样。
主要的区别就是地址不同(0000000000400570),链接器将这段代码的地址移到了一段不同的地址范围中。
其次 链接器填上了callq指令调用函数mult2 需要使用的地址；链接器的任务之一，就是为函数调用找到匹配的函数的可执行代码的位置。
最后，多了一些代码，这些代码对程序没有影响，因为出现在返回指令后面，插入这些指令是为了是函数代码变为16字节，就存储器系统性能而言，能更好的放置下一个代码块***

### 3.2.3 关于格式的注解
`linux> gcc -Og -S mstore.c`
查看内容
```
        .file   "mstore.c"
        .text
        .globl  multstore
        .type   multstore, @function
multstore:
.LFB11:
        .cfi_startproc
        pushq   %rbx
        .cfi_def_cfa_offset 16
        .cfi_offset 3, -16
        movq    %rdx, %rbx
        call    mult2
        movq    %rax, (%rbx)
        popq    %rbx
        .cfi_def_cfa_offset 8
        ret
        .cfi_endproc
.LFE11:
        .size   multstore, .-multstore
        .ident  "GCC: (GNU) 4.8.5 20150623 (Red Hat 4.8.5-39)"
        .section        .note.GNU-stack,"",@progbits
```
*所有以 “.” 开头的行都是知道汇编器和链接器工作的伪指令。通常可以忽略*

带解释的汇编代码如下：
```
void multstore(long x, long y, long *dest)
x in %rdi, y in %rsi, dest in %rdx
multstore:
    pushq   %rbx            // Save %rbx
    movq    %rdx, %rbx      // Copy dest to %rbx
    call    mult2           // Call mult2(x, y)
    movq    %rax, (%rbx)    // Store result at *dest
    popq    %rbx            // Restore %rbx
    ret                     // Return
```

## 3.3 数据格式
- 字 表示 16 位数据类型。32位数称为 双字 64位数称为 四字

| C声明 | Intel数据类型 | 汇编代码后缀 | 大小(字节) |
| :---: | :---: | :---: | :---: |
| char | 字节 | b | 1 |
| short | 字 | w | 2 |
| int | 双字 | l | 4 |
| long | 四字 | q | 8 |
| char* | 四字 | q | 8 |
| float | 单精度 | s | 4 |
| double | 双精度 | l | 8 |

> 后缀 “l” 用来表示双字，因为32位数被看成是 长字 。另外，汇编代码也使用后缀 “l” 来表示 4字节整数和 8字节双精度浮点数。这不会产生歧义，因为浮点数使用的是一组完全不同的指令和寄存器。

## 3.4 访问信息
- 一个 x86-64的CPU，包含一组 16个 存储 64位值的通用目的寄存器。

- 指令集演化历史：
    > 最初 8086 有 8 个 16位 的寄存器，寄下面图中 %ax 到 %bp。
    
    > 扩展到 IA32 架构时，寄存器也扩展成32位寄存器，标号从 %eax 到 %ebp。
    
    > 扩展到 x86-64后，原来的 8 个寄存器扩展成64位，标号从 %rax 到 %rbp。除此，还增加了 8 个新的寄存器，标号按照新的命名规则制定：从 %r8 到 %r15。

    ![](../../img/chapter-03/整数寄存器.jpg)

- 当复制和生成 1字节、2字节、4字节和8字节值的 指令，以寄存器作为目标时，对于生成小于 8字节结果的指令，寄存器中剩下的字节会怎样？
    - 生成 1字节 和 2字节 数字的指令 会保持剩下的字节不变
    - 生成 4字节 数字的指令会把高位 4个字节 置为0

- 在常见程序里不同的寄存器扮演不同的角色，最特别的事栈指针 %rsp，用来指明<font color="red">运行时栈的结束位置</font>。

### 3.4.1 操作数指示符
- 不同的操作数的可能性，被分为三种类型：
    > 立即数，表示常数值。在ATT格式的汇编中，立即数的书写方式是 ‘$’ 后面跟一个C表示法表示的整数 如 $0x1F

    > 寄存器，表示某个寄存器的内容。16个寄存器中的低位 1字节(8位)、2字节(16位)、4字节(32位)或8字节(64位) 中的一个 作为操作数

    > 内存引用，会根基计算出来的地址访问某个内存位置。
- 不同的寻址模式，对应不同形式的内存引用。

| 类型 | 格式 | 操作数值 | 名称 |
| :---: | :---: | :---: | :---: |
| 立即数 | $Imm | Imm | 立即数寻址 |
| 寄存器 | r<sub>a</sub>| R[r<sub>a</sub>] | 寄存器寻址 |
| 存储器 | Imm | M[Imm] | 绝对寻址 |
| 存储器 | (r<sub>a</sub>) | M[R[r<sub>a</sub>]] | 间接寻址 |
| 存储器 | Imm(r<sub>b</sub>) | M[Imm+R[r<sub>b</sub>]] | (基址+偏移量)寻址 |
| 存储器 | (r<sub>b</sub>,r<sub>i</sub>) | M[R[r<sub>b</sub>]+R[r<sub>i</sub>]] | 变址寻址 |
| 存储器 | Imm(r<sub>b</sub>,r<sub>i</sub>) | M[Imm+R[r<sub>b</sub>]+R[r<sub>i</sub>]] | 变址寻址 |
| 存储器 | (,r<sub>i</sub>,s)| M[R[r<sub>i</sub>] · S] | 比例变址寻址 |
| 存储器 | Imm(,r<sub>i</sub>,s) | M[Imm + R[r<sub>i</sub>] · S] | 比例变址寻址 |
| 存储器 | (r<sub>b</sub>,r<sub>i</sub>,s) | M[R[r<sub>b</sub>]+ R[r<sub>i</sub>] · S] | 比例变址寻址 |
| 存储器 | Imm(r<sub>b</sub>,r<sub>i</sub>,s) | M[Imm + R[r<sub>b</sub>]+ R[r<sub>i</sub>] · S] | 比例变址寻址 |

#### 练习题 3.1 假设下面的值存放在指明的内存地址和寄存器中

| 地址 | 值 |
| :-: | :-: |
| 0x100 | 0xFF |
| 0x104 | 0xAB |
| 0x104 | 0x13 |
| 0x104 | 0x11 |

| 寄存器 | 值 |
| :-: | :-: |
| %rax | 0x100 |
| %rcx | 0x1 |
| %rdx | 0x3 |

填写下表，给出所示操作数的值：
| 操作数 | 值 |
| :-: | :-: |
| %rax | <font color="red">0x100</font> |
| 0x104 | <font color="red">0xAB</font> |
| $0x108 | <font color="red">0x108</font> |
| (%rax) | <font color="red">0xFF</font> |
| 4(%rax) | <font color="red">0xAB</font> |
| 9(%rax, %rdx) | <font color="red">0x11</font> |
| 260(%rcx, %rdx) | <font color="red">0x13</font> |
| 0xFC(,%rcx,4) | <font color="red">0xFF</font> |
| (%rax, %rdx, 4) | <font color="red">0x11</font> |


### 3.4.2 数据传送指令
- 最频繁使用的指令

- MOV类指令。这些指令把数据从源位置复制到目的位置，不做任何变化。

| 指令 | 效果 | 描述 |
| :-: | :-: | :-: |
|mov s, d | d <- s | 传送 |
| movb ||传送字节|
| movw ||传送字|
| movl ||传送双字|
| movq ||传送四字|
| movabsq i -> r | r <- i | 传送绝对的四字 |

- 源操作数指定的值是一个立即数，存储在寄存器中或内存中。
- 目的操作数指定一个位置，要么是一个寄存器或者一个内存地址。
*x86-64 加了一条限制，传送指令的两个操作数不能都指向内存位置。*
- movabsq 能够以任意64位立即数值作为源操作数，并且只能以寄存器作为目的。

- MOVZ 和 MOVS 类指令。将较小的源值复制到较大的目的时使用。
    > MOVZ 类指令 把目的中 剩余的字节 填充为0
    > MOVS 类指令 通过符号扩展来填充，把源操作的最高位进行复制。
- 每条指令名字的最后两个字符都是大小指示符
    > 第一个字符指定源的大小，第二个指明目的的大小
    - MOVZ指令

    | 指令 | 效果 | 描述 |
    | :-: | :-: | :-: |
    |movz s, r | r <- 零扩展(s) | 以零扩展进行传送 |
    | movzbw || 将做了零扩展的字节传动到字 |
    | movzbl || 将做了零扩展的字节传动到双字 |
    | movzwl || 将做了零扩展的字传动到双字 |
    | movzbq || 将做了零扩展的字节传动到四字 |
    | movzwq || 将做了零扩展的字传动到四字 |

    - MOVS指令

    | 指令 | 效果 | 描述 |
    | :-: | :-: | :-: |
    | movs s, r | r <- 符号扩展(s) | 传送符号扩展的字节 |
    | movsbw || 将做了符号扩展的字节传送到字 |
    | movsbl || 将做了符号扩展的字节传送到双字 |
    | movswl || 将做了符号扩展的字传送到双字 |
    | movsbq || 将做了符号扩展的字节传送到四字 |
    | movswq || 将做了符号扩展的字传送到四字 |
    | movslq || 将做了符号扩展的双字传送到四字 |
    | cltq | %rax <- 符号扩展(%eax) | 将 %eax 符号扩展到 %rax |

    *cltq指令只作用于寄存器 %eax和%rax*

#### 练习题 3.2 
对于下列汇编代码，根据操作数，确定适当的指令后缀

mov<font color="red">l</font>     %eax, (%rsp)
mov<font color="red">w</font>     (%rax),%dx
mov<font color="red">b</font>     $0xFF,%bl
mov<font color="red">b</font>     (%rsp,%rdx,4),%dl
mov<font color="red">q</font>     (%rdx),%rax
mov<font color="red">w</font>     %dx,(%rax)

#### 练习题 3.3
纠错
 movb $0xF,(%ebx)
 <font color="red">不能使用%ebx作为地址寄存器</font>
 movl %rax,(%rsp)
 <font color="red">指令后缀和寄存器ID不匹配</font>
 movw (%rax),4(%rsp)
 <font color="red">不能让源和目标都是内存引用</font>
 movb %al,%sl
 <font color="red">没有名为%sl的寄存器</font>
 movq %rax,$0x123 
 <font color="red">目的操作数不应该为立即数</font>
 movl %eax,%rdx
 <font color="red">目标操作数大小不正确</font>
 movb %si,8(%rbp)
 <font color="red">指令后缀和寄存器ID不匹配</font>

### 3.4.3 数据传送示例
一组交换代码
```C
long exchange(long *xp, long y)
{
    long x = *xp;
    *xp = y;
    return x;
}
````

对应的汇编
```bash
exchange:
.LFB11:
    .cfi_startproc
    movq    (%rdi), %rax
    movq    %rsi, (%rdi)
    ret
    .cfi_endproc
```

_说明了mov指令从内存中读值到寄存器(`movq (%rdi),%rax`),如何从寄存器写到内存(`movq %rsi,(%rdi)`)_

#### 练习题 3.4
假设变量 sp 和 dp 被声明为类型
```
src_t *sp;
dest_t *dp;
```
这里src_t 和 dest_t 是用typedef声明的数据类型。我们想使用适当的数据传送指令还实现下面的操作
```
*dp = (dest_t) *sp;
```
假设sp和dp的值分别存储在寄存器%rdi和%rsi中。 对于表中的每个表项， 给出 实现指定数据传送的两条指令。 其中第一条指令应该从内存中读数， 做适当的转换， 并 设置寄存器%rax 的适当部分。 然后， 第二条指令要把%rax 的适当部分写到 内存。 在这 两种情况中， 寄存器的部分可以是%rax、%eax、%ax或%al, 两者可以互不相同。
记住， 当执行强制类型转换既涉及大小变化又涉及C语言中符号变化时， 操作应 该先改变大小(2. 2. 6 节)。

| src_t | dest_t | 指令 |
|:-:|:-|:-|
| long | long | movq (%rdi),  %rax <br>  movq %rax,(%rsi)|
| char | int  | <font color="red">novsbl (%rdi), %eax <br>  movl %eax,(%rsi)</font> |
| char | unsigned | <font color="red">movsbl (%rdi),%eax <br>  movl %eax,(%rsi)</font> |
| unsigned char | long | <font color="red">movzbl (%rdi),%eax <br> movq %rax,(%rsi)</font> |
| int | char | <font color="red">movl (%rdi),%eax <br> movb %al,(%rsi)</font> |
| unsigned | unsigned char | <font color="red">movl (%rdi),%eax <br> movb %al, (%rsi)</font> |
| char | short | <font color="red">movsbw (%rdi),%ax <br> movw %ax,(%rsi)</font> |

#### 练习题 3.5
已知信息如下。将一个原型为
`void decode1(long *xp, long *yp, long *zp);`
的函数编译成汇编代码，得到如下代码：
```
void decode1(long *xp, long *yp, long *zp)
xp in %rdi, yp in %rsi, zp in %rdx
decode1:
    movq (%rdi), %r8
    movq (%rsi), %rcx
    movq (%rdx), %rax
    movq %r8, (%rsi)
    movq %rcx, (%rdx)
    movq %rax, (%rdi)
    ret
```
<font color="red">C代码：</font>

```
void decode1(long *xp, long *yp, long *zp)
{
    long x = *xp;
    long y = *yp;
    long z = *zp;

    *yp = x;
    *zp = y;
    *xp = z;
}
```

参数xp、yp、zp分别存储在对应的寄存器%rdi,%rsi和%rdx中
请写出等效于上面汇编代码的 decode1 的C代码。

### 3.4.4 压入和弹出栈数据
- 栈：后进先出
_弹出的值永远是最近被压入而且仍然在栈中的值。_
_栈可以实现为一个数组，总是从数组的一端插入和删除元素，这一端被称为栈顶_

- 将一个四字值压入栈中，首先要将栈指针减8，然后将值写到新的栈顶地址。因此指令 `pushq %rbp`的行为等价于下面两条指令：
    ```
    subq $8 %rsp        # 减堆栈指针
    movq %rbp,(%rsp)    # 将%rbp存储在堆栈上
    ```
    _两者之间的区别是，在机器代码中， pushq指令编码为1个字节，上面需要8个字节_
- 弹出一个四字的操作包括从栈顶位置读出数据，然后将栈指针加8。因此指令`popq %rax`等价于下面两条指令：
    ```
    movq (%rsp), %rax   # 从堆栈中读取%rax
    addq $8, %rsp       # 增量栈指针
    ```
- 无论如何，%rsp指向的地址总是栈顶

## 3.5 算术和逻辑操作
- 一些整数和逻辑操作。

| 指令 | 效果 | 描述 |
| :- | :-| :- |
| leaq S, D | D <- %S | 加载有效地址 |
| INC D <BR> DEC D <BR> NEG D <BR> NOT D | D<-D+1 <BR> D<-D-1 <BR> D<- -D <BR> D<-~D| 加1 <BR> 减1 <BR> 取负 <BR> 取补|
| ADD S, D <BR> SUB S, D <BR> IMUL S, D <BR> XOR S, D <BR> OR S, D <BR> AND S, D | D<-D+S <BR> D<-D-S <BR> D<- D*S <BR> D<- D^S  <BR> D <- D\|S <BR> D<- D&S | 加 <BR> 减 <BR> 乘 <BR> 异或 <BR>  或 <BR> 与|
| SAL k, D <BR> SHL k, D <BR> SAR k, D <BR> SHR k, D | D<-D << k <BR> D<-D << k <BR> D<- D >><sub>A</sub> k <BR> D<- D >><sub>L</sub> k | 左移 <BR> 左移(等同于SAL) <BR> 算术右移 <BR> 逻辑右移|

- 这些指令除了leap之外，都有各种带不同大小操作数的变种，eg. 指令类ADD由四条加法指令组成:addb、addw、addl、addq，分别是字节加法，字加法，双字加法和四字加法。

### 3.5.1 加载有效地址
- leaq指令实际上是movq指令的变形，指令形式是从内存读数据到寄存器，但实际上它根本没有引用内存。
- leaq目的操作数必须是个寄存器
_第一个操作数看起来是一个内存引用，但该指令并不是从指定的位置读入数据，而是将有效地址写入目的操作数。_

- leaq指令能执行加法和有限形式的乘法，在编译如上简单的算术表达式时，是很有用处的。

#### 练习题 3.6 假设寄存器 %rax的值为x，%rcx的值为y。填写下表，指明下面每条汇编代码指令存储在寄存器 %rdx 中的值：

| 表达式 | 结果 |
| :- | :-: |
| leaq 6(%ax), %rdx | <font color="red">6+x</font> |
| leaq (%rax, %rcx), %rdx | <font color="red">x+y</font> |
| leaq (%rax, %rcx, 4), %rdx | <font color="red">x+4y</font> |
| leaq 7(%rax, %rax, 8), %rdx | <font color="red">7+9x</font> |
| leaq 0xA(, %rcx, 4), %rdx | <font color="red">10+4y</font> |
| leaq 9(%rax, %rcx, 2), %rdx | <font color="red">9+x+2y</font> |

#### 练习题 3.7 考虑下面的代码，我们省略了被计算的表达式：
```
long scale2(long x, long y, long z) {
    long t = ( 5 * x + 2 * y + 8 * z ) ;
    return t;
}
```
用GCC编译实际的函数得到如下的汇编代码：
```
long scale2(long x, long y, long z)
x in %rdi, y in %rsi,z in %rdx
scale2:
leaq    (%rdi,%rdi,4), %rax
leaq    (%rax,%rsi,2), %rax
leaq    (%rax,%rdx,8), %rax
ret
```
填写出 C 代码中确实的表达式。
`long t = 5 * x + 2 * y + 8 * z ;`
### 3.5.2 一元和二元操作
- 一元操作，只有一个操作数，既是源，又是目的。可以是一个寄存器，也可以是一个内存位置。
- 二元操作，两个操作数，第二个操作数既是源又是目的。第一个操作数可以是立即数、寄存器或者内存位置。第二个操作数可以是寄存器或者内存位置。
_当第二个操作数为内存地址时，处理器必须从内存读出值，执行操作，再把结果写回内存。_

#### 练习题 3.8 
假设下面的值存放在指定的内存地址和寄存器中：

| 地址 | 值 |
| :-: | :-: |
| 0x100 | 0xFF |
| 0x108 | 0xAB |
| 0x110 | 0x13 |
| 0x118 | 0x11 |

| 寄存器 | 值 |
| :-: | :-: |
| %rax | 0x100 |
| %rcx | 0x1 |
| %rdx | 0x3 |

填写下表，给出下面指令的效果，说明将被更新的寄存器或内存位置，以及得到的值：

| 指令 | 目的 | 值 |
| :- | :-: | :-: |
| addq %rcx, (%rax) |<font color="red">0x100</font>|<font color="red">0x100</font>|
| subq %rdx, 8(%rax) |<font color="red">0x108</font>|<font color="red">0xAB</font>|
| imulq $16, (%rax,%rdx,8) |<font color="red">0x118</font>|<font color="red">0x110</font>|
| incq 16(%rax) |<font color="red">0x110</font>|<font color="red">0x14</font>|
| decq %rcx |<font color="red">%rcx</font>|<font color="red">0x0</font>|
| subq %rdx, %rax |<font color="red">%rax</font>|<font color="red">0xFD</font>|

### 3.5.3 移位操作
- 第一个操作数是移位量，第二个操作数是要移位的数。
- 可以进行算术和逻辑右移
- 移位量可以是一个立即数，或者放在单字节寄存器 %cl 中。
- 目的操作数可以是一个寄存器或是一个内存位置。

#### 练习题 3.9 假设我们想生成以下C函数的汇编代码：
```
long shift_left4_rightn(long x, long n)
{
    x <<= 4;
    x >>= n;
    return x;
}
```
下面这段汇编代码执行实际的移位，并将最后的结果放在寄存器 %rax 中。此处省略了两条关键的指令。参数x和n分别存放在寄存器 %rdi 和 %rsi 中。
```
long shift_left4_rightn(long x, long n)
x in %rdi, n in %rsi
shift_left4_rightn:
    movq    %rdi, %rax      # Get x
    (salq   $4, %rax)       # x <<= 4
    movl    %esi, %ecx      # Get n (4 bytes)
    (sarq   %cl, %rax)      # x >>= n
```
根据右边的注释，填出确实的指令。请使用算术右移操作。

### 3.5.4 讨论
### 3.5.5 特殊的算术操作

## 3.6 控制

### 3.6.1 条件码
- 常见条件码
> CF: 进位标志。最近的操作使最高位产生了进位。可用来检查无符号操作的溢出。
ZF: 零标志。最近的操作得出的结果为0。
SF: 符号标志。最近的操作得到的结果为负数。
OF: 溢出标志。最近的操作导致一个补码溢出——正溢出或负溢出。

- leaq 指令不改变任何条件码。因为是用来进行地址计算的。
- 除了一些整数和逻辑操作会设置条件码，还有两类指令，只设置条件码而不改变任何其他寄存器。

| 指令 | 基于 | 描述 |
|:-:|:-:|:-:|
| CMP S<sub>1</sub>, S<sub>2</sub> | S<sub>2</sub> <- S<sub>1</sub> | 比较 |
| TEST S<sub>1</sub>, S<sub>2</sub> | S<sub>2</sub> & S<sub>1</sub> | 测试 |

_cmpb、cmpw、cmpl、cmpq 分别比较 字节、字、双字、四字_
_testb、testw、testl、testq 分别测试 字节、字、双字、四字_

### 3.6.2 访问条件码
- 条件码通常不会直接读取，常用的使用方法有三种：
    - 可以根据条件码的某种组合，将一个字节设置为0或者1
    - 可以条件跳转到程序的某个其他的部分
    - 可以有条件的传送数据

- 第一种情况：SET指令类。区别在于它们考虑的条件码的组合是什么，指令不同的后缀指明了他们所考虑的条件码的组合。
_指令后缀表示不同的条件而不是操作数大小，eg.setl和setb表示  “小于时设置” 和 “低于时设置”_

- 一个SET指令的目的操作数是低位单字节寄存器元素之一，或者是一个字节的内存位置，指令会将这个字节设置成0或者1。为了得到一个32位或64位结果，我们必须对高位清零。




## 3.7 过程

## 3.8 数组分配和访问

## 3.9 异数的数据结构

## 3.10 在机器级程序中将控制与数据结合起来

## 3.11 浮点代码

## 3.12 小结