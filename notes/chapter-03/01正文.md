# 正文

## 3.1 历史观点

- K表示1 000  M表示 1 000 000  G表示 1 000 000 000
 
> 8086 第一代单芯片、16位微处理器之一。 8088 是 8086 的一个变种，在8086基础上增加了一个8位外部总线。

> i386 (275k个晶体管)。将体系结构扩展到32位。增加了平坦寻址模式。是Intel系列中第一台全面支持Unix操作系统的机器。

## 3.2 程序编码
假设：一个C程序，有两个文件 p1.c 和 p2.c 。用Unix命令行编译这些代码：
`linux> gcc -Og -o p p1.c p2.c`
(-Og  大写的字母 ‘O’)

*-Og 是告诉编译器使用 会生成 符合原始C代码 整体结构的机器代码的优化等级*

- 抽象1：指令集体系结构或指令集架构(ISA)，定义机器级程序的格式和行为，定义了处理器状态、指令的格式、以及每条指令对状态的影响。
- 抽象2：虚拟地址，是机器级程序使用的内存地址。提供的内存模型看上去是一个非常大的字节数组。

### 3.2.1 机器级代码
- 程序计数器(PC),给出将要执行下一条指令在内存中的地址。
- 整数寄存器文件，包含16个命名的位置，分别存储64位的值。这些寄存器可以存储地址(对应于C语言的指针)或整数数据。有的寄存器被用来记录某些重要的程序状态，其他的寄存器用来保存临时数据。
- 条件码寄存器， 保存最近执行的算术或逻辑指令的状态信息。用来实现控制或数据流中的条件变化，比如if和while语句。
- 一组向量寄存器可以存放一个或多个整数或浮点数值。
- 虽然C语言提供了一种模型，可以在内存中声明和分配各种数据类型的对象。但是机器代码只是简单地将内存看成一个很大的、按字节寻址的数组。
- C语言中的聚合数据类型，例如数组和结构，在机器代码中用一组连续的字节来表示。
- <font color="red">即使对标量数据类型，汇编代码也不区分有符号或无符号整数，不区分各种类型的指针，甚至不区分指针和整数。</font>
*标量类型（Scalar type）是相对复合类型（Compound type）来说的：标量类型只能有一个值，而复合类型可以包含多个值。复合类型是由标量类型构成的。如：int，char，enum，float等*

- 程序内存包括：
    > 可执行机器代码、操作系统需要的一些信息、用来管理过程调用和返回的运行时栈、用户分配的内存块（比如说用malloc库函数分配的）
- 操作系统负责管理虚拟地址空间，将虚拟地址翻译成实际处理器内存中的物理地址。
- 一条机器指令只执行一个非常基本的操作。

### 3.2.2 代码示例

mstore.c
```C
long mult2(long, long);
void multstore(long x, long y, long *dest)
{
    long t = mult2(x, y);
    *dest = t
}
```

- 在命令行使用 “-S” 选项，能看到C语言编译器产生的汇编代码：
`linux> gcc -Og -S mstore.c`

- 使用 “-c” 选项，GCC会编译并汇编该代码：
`linux> gcc -Og -c mstore.c`

```
在文件 mstore.o上运行GDB
linux> gdb multstore.o

输入命令：
(gdb) x/14xb multstore

该命令的含义是，告诉GDB 显示(简写为'x')从函数multstore所处地址开始
的 14 个 十六进制格式表示 (简写为'x')的字节(简写为'b')
```

- 在Linux系统中，带 '-d' 命令行标志的程序 objdump 可以查看机器代码文件，根据机器代码产生一种类似于汇编代码的格式：
`linux> objdump -d mstore.o`

结果如下：
```S
mstore.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <multstore>:
   0:   53                      push   %rbx
   1:   48 89 d3                mov    %rdx,%rbx
   4:   e8 00 00 00 00          callq  9 <multstore+0x9>
   9:   48 89 03                mov    %rax,(%rbx)
   c:   5b                      pop    %rbx
   d:   c3                      retq   
```

- 生成实际可执行的代码需要对一组目标代码文件运行链接器，而这一组目标代码文件中必须含有一个main函数。
```C
  1 #include <stdio.h>
  2 
  3 int main()
  4 {
  5     long d;
  6     multstore(2, 3, &d);
  7     printf("2 * 3 --> %ld\n", d);
  8     return 0;                                                                                                                                           
  9 }   
 10 
 11 long mult2(long a, long b)
 12 {
 13     long s = a * b;
 14     return s;
 15 }   
```

- 用gcc中的 '-o' 指令，生成可执行文件prog：
`linux> gcc -Og -c prog main.c multstore.c`

- 反汇编这个prog文件，会发现这样一段代码：
```
0000000000400570 <multstore>:
  400570:       53                      push   %rbx
  400571:       48 89 d3                mov    %rdx,%rbx
  400574:       e8 ef ff ff ff          callq  400568 <mult2>
  400579:       48 89 03                mov    %rax,(%rbx)
  40057c:       5b                      pop    %rbx
  40057d:       c3                      retq   
  40057e:       66 90                   xchg   %ax,%ax
```

***与mstore.c反汇编产生的代码几乎完全一样。
主要的区别就是地址不同(0000000000400570),链接器将这段代码的地址移到了一段不同的地址范围中。
其次 链接器填上了callq指令调用函数mult2 需要使用的地址；链接器的任务之一，就是为函数调用找到匹配的函数的可执行代码的位置。
最后，多了一些代码，这些代码对程序没有影响，因为出现在返回指令后面，插入这些指令是为了是函数代码变为16字节，就存储器系统性能而言，能更好的放置下一个代码块***

### 3.2.3 关于格式的注解
`linux> gcc -Og -S mstore.c`
查看内容
```
        .file   "mstore.c"
        .text
        .globl  multstore
        .type   multstore, @function
multstore:
.LFB11:
        .cfi_startproc
        pushq   %rbx
        .cfi_def_cfa_offset 16
        .cfi_offset 3, -16
        movq    %rdx, %rbx
        call    mult2
        movq    %rax, (%rbx)
        popq    %rbx
        .cfi_def_cfa_offset 8
        ret
        .cfi_endproc
.LFE11:
        .size   multstore, .-multstore
        .ident  "GCC: (GNU) 4.8.5 20150623 (Red Hat 4.8.5-39)"
        .section        .note.GNU-stack,"",@progbits
```
*所有以 “.” 开头的行都是知道汇编器和链接器工作的伪指令。通常可以忽略*

带解释的汇编代码如下：
```
void multstore(long x, long y, long *dest)
x in %rdi, y in %rsi, dest in %rdx
multstore:
    pushq   %rbx            // Save %rbx
    movq    %rdx, %rbx      // Copy dest to %rbx
    call    mult2           // Call mult2(x, y)
    movq    %rax, (%rbx)    // Store result at *dest
    popq    %rbx            // Restore %rbx
    ret                     // Return
```

## 3.3 数据格式
- 字 表示 16 位数据类型。32位数称为 双字 64位数称为 四字

| C声明 | Intel数据类型 | 汇编代码后缀 | 大小(字节) |
| :---: | :---: | :---: | :---: |
| char | 字节 | b | 1 |
| short | 字 | w | 2 |
| int | 双字 | l | 4 |
| long | 四字 | q | 8 |
| char* | 四字 | q | 8 |
| float | 单精度 | s | 4 |
| double | 双精度 | l | 8 |

> 后缀 “l” 用来表示双字，因为32位数被看成是 长字 。另外，汇编代码也使用后缀 “l” 来表示 4字节整数和 8字节双精度浮点数。这不会产生歧义，因为浮点数使用的是一组完全不同的指令和寄存器。

## 3.4 访问信息
- 一个 x86-64的CPU，包含一组 16个 存储 64位值的通用目的寄存器。

- 指令集演化历史：
    > 最初 8086 有 8 个 16位 的寄存器，寄下面图中 %ax 到 %bp。
    
    > 扩展到 IA32 架构时，寄存器也扩展成32位寄存器，标号从 %eax 到 %ebp。
    
    > 扩展到 x86-64后，原来的 8 个寄存器扩展成64位，标号从 %rax 到 %rbp。除此，还增加了 8 个新的寄存器，标号按照新的命名规则制定：从 %r8 到 %r15。

    ![](../../img/chapter-03/整数寄存器.jpg)

- 当复制和生成 1字节、2字节、4字节和8字节值的 指令，以寄存器作为目标时，对于生成小于 8字节结果的指令，寄存器中剩下的字节会怎样？
    - 生成 1字节 和 2字节 数字的指令 会保持剩下的字节不变
    - 生成 4字节 数字的指令会把高位 4个字节 置为0

- 在常见程序里不同的寄存器扮演不同的角色，最特别的事栈指针 %rsp，用来指明<font color="red">运行时栈的结束位置</font>。

### 3.4.1 操作数指示符
- 不同的操作数的可能性，被分为三种类型：
    > 立即数，表示常数值。在ATT格式的汇编中，立即数的书写方式是 ‘$’ 后面跟一个C表示法表示的整数 如 $0x1F

    > 寄存器，表示某个寄存器的内容。16个寄存器中的低位 1字节(8位)、2字节(16位)、4字节(32位)或8字节(64位) 中的一个 作为操作数

    > 内存引用，会根基计算出来的地址访问某个内存位置。
- 不同的寻址模式，对应不同形式的内存引用。

| 类型 | 格式 | 操作数值 | 名称 |
| :---: | :---: | :---: | :---: |
| 立即数 | $Imm | Imm | 立即数寻址 |
| 寄存器 | r<sub>a</sub>| R[r<sub>a</sub>] | 寄存器寻址 |
| 存储器 | Imm | M[Imm] | 绝对寻址 |
| 存储器 | (r<sub>a</sub>) | M[R[r<sub>a</sub>]] | 间接寻址 |
| 存储器 | Imm(r<sub>b</sub>) | M[Imm+R[r<sub>b</sub>]] | (基址+偏移量)寻址 |
| 存储器 | (r<sub>b</sub>,r<sub>i</sub>) | M[R[r<sub>b</sub>]+R[r<sub>i</sub>]] | 变址寻址 |
| 存储器 | Imm(r<sub>b</sub>,r<sub>i</sub>) | M[Imm+R[r<sub>b</sub>]+R[r<sub>i</sub>]] | 变址寻址 |
| 存储器 | (,r<sub>i</sub>,s)| M[R[r<sub>i</sub>] · S] | 比例变址寻址 |
| 存储器 | Imm(,r<sub>i</sub>,s) | M[Imm + R[r<sub>i</sub>] · S] | 比例变址寻址 |
| 存储器 | (r<sub>b</sub>,r<sub>i</sub>,s) | M[R[r<sub>b</sub>]+ R[r<sub>i</sub>] · S] | 比例变址寻址 |
| 存储器 | Imm(r<sub>b</sub>,r<sub>i</sub>,s) | M[Imm + R[r<sub>b</sub>]+ R[r<sub>i</sub>] · S] | 比例变址寻址 |

#### 练习题 3.1 假设下面的值存放在指明的内存地址和寄存器中

| 地址 | 值 |
| :-: | :-: |
| 0x100 | 0xFF |
| 0x104 | 0xAB |
| 0x104 | 0x13 |
| 0x104 | 0x11 |

| 寄存器 | 值 |
| :-: | :-: |
| %rax | 0x100 |
| %rcx | 0x1 |
| %rdx | 0x3 |

填写下表，给出所示操作数的值：
| 操作数 | 值 |
| :-: | :-: |
| %rax | <font color="red">0x100</font> |
| 0x104 | <font color="red">0xAB</font> |
| $0x108 | <font color="red">0x108</font> |
| (%rax) | <font color="red">0xFF</font> |
| 4(%rax) | <font color="red">0xAB</font> |
| 9(%rax, %rdx) | <font color="red">0x11</font> |
| 260(%rcx, %rdx) | <font color="red">0x13</font> |
| 0xFC(,%rcx,4) | <font color="red">0xFF</font> |
| (%rax, %rdx, 4) | <font color="red">0x11</font> |


### 3.4.2 数据传送指令
- 最频繁使用的指令

- MOV类指令。这些指令把数据从源位置复制到目的位置，不做任何变化。

| 指令 | 效果 | 描述 |
| :-: | :-: | :-: |
|mov s, d | d <- s | 传送 |
| movb ||传送字节|
| movw ||传送字|
| movl ||传送双字|
| movq ||传送四字|
| movabsq i -> r | r <- i | 传送绝对的四字 |

- 源操作数指定的值是一个立即数，存储在寄存器中或内存中。
- 目的操作数指定一个位置，要么是一个寄存器或者一个内存地址。
*x86-64 加了一条限制，传送指令的两个操作数不能都指向内存位置。*
- movabsq 能够以任意64位立即数值作为源操作数，并且只能以寄存器作为目的。

- MOVZ 和 MOVS 类指令。将较小的源值复制到较大的目的时使用。
    > MOVZ 类指令 把目的中 剩余的字节 填充为0
    > MOVS 类指令 通过符号扩展来填充，把源操作的最高位进行复制。
- 每条指令名字的最后两个字符都是大小指示符
    > 第一个字符指定源的大小，第二个指明目的的大小
    - MOVZ指令

    | 指令 | 效果 | 描述 |
    | :-: | :-: | :-: |
    |movz s, r | r <- 零扩展(s) | 以零扩展进行传送 |
    | movzbw || 将做了零扩展的字节传动到字 |
    | movzbl || 将做了零扩展的字节传动到双字 |
    | movzwl || 将做了零扩展的字传动到双字 |
    | movzbq || 将做了零扩展的字节传动到四字 |
    | movzwq || 将做了零扩展的字传动到四字 |

    - MOVS指令

    | 指令 | 效果 | 描述 |
    | :-: | :-: | :-: |
    | movs s, r | r <- 符号扩展(s) | 传送符号扩展的字节 |
    | movsbw || 将做了符号扩展的字节传送到字 |
    | movsbl || 将做了符号扩展的字节传送到双字 |
    | movswl || 将做了符号扩展的字传送到双字 |
    | movsbq || 将做了符号扩展的字节传送到四字 |
    | movswq || 将做了符号扩展的字传送到四字 |
    | movslq || 将做了符号扩展的双字传送到四字 |
    | cltq | %rax <- 符号扩展(%eax) | 将 %eax 符号扩展到 %rax |

    *cltq指令只作用于寄存器 %eax和%rax*

#### 练习题 3.2 
对于下列汇编代码，根据操作数，确定适当的指令后缀

mov<font color="red">l</font>     %eax, (%rsp)
mov<font color="red">w</font>     (%rax),%dx
mov<font color="red">b</font>     $0xFF,%bl
mov<font color="red">b</font>     (%rsp,%rdx,4),%dl
mov<font color="red">q</font>     (%rdx),%rax
mov<font color="red">w</font>     %dx,(%rax)

#### 练习题 3.3
纠错
 movb $0xF,(%ebx)
 <font color="red"></font>
 movl %rax,(%rsp)
 <font color="red"></font>
 movw (%rax),4(%rsp)
 <font color="red"></font>
 movb %al,%sl
 <font color="red"></font>
 movq %rax,$0x123 
 <font color="red">目的操作数不应该为立即数</font>
 movl %eax,%rdx
 <font color="red"></font>
 movb %si,8(%rbp)
 <font color="red"></font>

### 3.4.3 数据传送示例
一组交换代码
```C
long exchange(long *xp, long y)
{
    long x = *xp;
    *xp = y;
    return x;
}
````

对应的汇编
```bash
exchange:
.LFB11:
    .cfi_startproc
    movq    (%rdi), %rax
    movq    %rsi, (%rdi)
    ret
    .cfi_endproc
```

_说明了mov指令从内存中读值到寄存器(`movq (%rdi),%rax`),如何从寄存器写到内存(`movq %rsi,(%rdi)`)_

#### 练习题 3.4
假设变量 sp 和 dp 被声明为类型
```
src_t *sp;
dest_t *dp;
```
这里src_t 和 dest_t 是用typedef声明的数据类型。我们想使用适当的数据传送指令还实现下面的操作
```
*dp = (dest_t) *sp;
```
假设sp和dp的值分别存储在寄存器%rdi和%rsi中。 对于表中的每个表项， 给出 实现指定数据传送的两条指令。 其中第一条指令应该从内存中读数， 做适当的转换， 并 设置寄存器%rax 的适当部分。 然后， 第二条指令要把%rax 的适当部分写到 内存。 在这 两种情况中， 寄存器的部分可以是%rax、%eax、%ax或%al, 两者可以互不相同。
记住， 当执行强制类型转换既涉及大小变化又涉及C语言中符号变化时， 操作应 该先改变大小(2. 2. 6 节)。

| src_t | dest_t | 指令 |
|:-:|:-:|:-:|
| long | long | movq (%rdi),  %rax<br>  movq %rax,(%rsi)|
| char | int  | <font color="red"></font> |
| char | unsigned | <font color="red"></font> |
| unsigned char | long | <font color="red"></font> |
| int | char | <font color="red"></font> |
| unsigned | unsigned char | <font color="red"></font> |
| char | short | <font color="red"></font> |

#### 练习题 3.5
已知信息如下。将一个原型为
`void decode1(long *xp, long *yp, long *zp);`
的函数编译成汇编代码，得到如下代码：
```
void decode1(long *xp, long *yp, long *zp)
xp in %rdi, yp in %rsi, zp in %rdx
decode1:
    movq (%rdi), %r8
    movq (%rsi), %rcx
    movq (%rdx), %rax
    movq %r8, (%rsi)
    movq %rcx, (%rdx)
    movq %rax, (%rdi)
    ret
```
参数xp、yp、zp分别存储在对应的寄存器%rdi,%rsi和%rdx中
请写出等效于上面汇编代码的 decode1 的C代码。

### 3.4.4 压入和弹出栈数据
- 栈：后进先出
_弹出的值永远是最近被压入而且仍然在栈中的值。_
_栈可以实现为一个数组，总是从数组的一端插入和删除元素，这一端被称为栈顶_

- 将一个四字值压入栈中，首先要将栈指针减8，然后将值写到新的栈顶地址。因此指令 `pushq %rbp`的行为等价于下面两条指令：
    ```
    subq $8 %rsp        # 减堆栈指针
    movq %rbp,(%rsp)    # 将%rbp存储在堆栈上
    ```
    _两者之间的区别是，在机器代码中， pushq指令编码为1个字节，上面需要8个字节_
- 弹出一个四字的操作包括从栈顶位置读出数据，然后将栈指针加8。因此指令`popq %rax`等价于下面两条指令：
    ```
    movq (%rsp), %rax   # 从堆栈中读取%rax
    addq $8, %rsp       # 增量栈指针
    ```
- 无论如何，%rsp指向的地址总是栈顶

## 3.5 算术和逻辑操作

## 3.6 控制

## 3.7 过程

## 3.8 数组分配和访问

## 3.9 异数的数据结构

## 3.10 在机器级程序中将控制与数据结合起来

## 3.11 浮点代码

## 3.12 小结