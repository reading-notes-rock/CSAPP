# 正文

## 2.1 信息存储
- 1字节 = 8位 = 最小的可寻址的内存单位
- 虚拟内存：机器级程序将内存视为一个非常大的<font color="red">*字节数组*</font>，成为虚拟内存
- 内存的每个字节都由一个唯一的数字来标识，称为它的<font color="red">*地址*</font>，所有可能地址的集合称为<font color="red">*虚拟地址空间*</font>

### 2.1.1 十六进制表示法
- 十六进制使用数字 0 ~ 9 以及 A ~ F 来表数16个可能的值。
- 以`0x`或 `0X`开头的数字常量被认为是十六进制的值。字符 A ~ F可以大写或者小写。

| 十六进制数字 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 十进制值 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 |
| 二进制值 | 0000 | 0001 | 0010 | 0011 | 0100 | 0101 | 0110 | 0111 | 1000 | 1001 | 1010 | 1011 | 1100 | 1101 | 1110 | 1111 |

#### 练习题2.1 完成数字转换
A. 将 0x39A7F8 转换为二进制
解答：<font color="red">11 1001 1010 0111 1111 1000</font>
B. 将二进制 1100100101111011 转换为十六进制
解答：<font color="red">OxC97B</font>
C. 将 0xD5E4C 转换为二进制
解答：<font color="red">1101 0101 1110 0100 1100</font>
D. 将二进制 10 0110 1110 0111 1011 0101 转换为十六进制
解答：<font color="red">0x26E7B5</font>

*小技巧*
> 当值 x = 2<sup>n</sup> ,n 为非负整数时，很容易将x写成十六进制。x的二进制表示就是1后面跟n个0
> 当 n 表示成 i +4j 形式，其中 0 <= i <= 4,可以把x写成，开头的十六进制数字为1(i=0),2(i=1),4(i=2),8(i=3),后面跟着j个十六进制的0。
> 比如  4096 = 2<sup>12</sup>,n = 12 = i + 4j = 0 + 4 *3。i = 0,j = 3,可得出 4096的十六进制为 0x1000。

#### 练习题2.2 填写表中的空白项，给出2的不同次幂的二进制和十六进制表示：
| n | 2<sup>n</sup>(十进制) | 2<sup>n</sup>(十六进制) |
| :---: | :---: | :---: |
| 9 | 512 | 0x200 |
| 19 | <font color="red">524288</font> | <font color="red">0x80000</font> | 
| <font color="red">14</font> |16384| <font color="red">0x4000</font> |
| <font color="red">16</font> | <font color="red">65536</font> |0x10000|
|17| <font color="red">131072</font> | <font color="red">0x20000</font> |
| <font color="red">5</font> |32| <font color="red">0x20</font> |
| <font color="red">7</font> | <font color="red">128</font> |0x80|

*小技巧*
>  十进制转十六进制：反复除以16，得到商和余数，余数作为最低位，继续用商除以16，直到最后

> 十六进制转十进制：用响应的16的幂乘每个十六进制数字。

#### 练习题2.3 一个字节可以用两个十六进制数字来表示。填写下表，给出不同的字节模式的二进制、十进制、十六进制的值。

| 十进制 | 二进制 | 十六进制 |
| :---: | :---: | :---: |
| 0 | 0000 0000 | 0x00 |
| 167 | <font color="red">1010 0111</font> | <font color="red">0xA7</font> | 
| 62 | <font color="red">0011 1110</font> | <font color="red">0x3E</font> |
| 188 | <font color="red">1011 1100</font> |<font color="red">0xBC</font> |
| <font color="red">55</font>| 0011 0111 | <font color="red">0x37</font> |
| <font color="red">136</font> |1000 1000 | <font color="red">0x88</font> |
| <font color="red">243</font> | 1111 0011 |<font color="red">0xF3</font> |
| <font color="red">82</font> | <font color="red">0101 0010</font> |0x52|
| <font color="red">172</font> | <font color="red">1010 1100</font> |0xAC|
| <font color="red">231</font> | <font color="red">1110 0111</font> |0xE7|

#### 练习题2.4 算术题
A. 0x503c + 0x8 = <font color="red">0x5044</font>

B. 0x503c - 0x40 = <font color="red">0x4FFC</font>

C. 0x503c + 64 = <font color="red">0x507C</font>

D. 0x50ea - 0x503c = <font color="red">0xAE</font>

### 2.1.2 字数据大小
- 字长指明指针数据的标称大小，因为虚拟地址是以一个字来编码的。
- 对于一个字长为w位的机器而言，虚拟地址的范围为2<sup>w</sup>-1

- 基本C数据类型的典型大小

| C声明 |  | 字节数 ||
| :---: | :---: | :---: | :---: |
| 有符号 | 无符号 | 32位 | 64位 |
| [signed] char | unsigned char | 1 | 1 |
| short | unsigned short | 2 | 2 |
| int | unsigned | 4 | 4 |
| long | unsigned long | 4 | 8 |
| int32_t | uint32_t | 4 | 4 |
| int64_t | uint64_t | 8 | 8 |
| char * | | 4 | 8 |
| float | | 4 | 4 |
| double | | 8 | 8 |

### 2.1.3 寻址和字节顺序
- 小端法：最低有效字节在最前面的方式
- 大端法：最高有效字节在最前面的方式

### 2.1.4 表示字符串
### 2.1.5 表示代码
### 2.1.6  布尔代数简介
- 布尔代数在二元集合{0, 1} 基础上定义。 ~、&、| 、 ^

### 2.1.7 C语言中的位级运算

### 2.1.8 C语言中的逻辑运算

### 2.1.9 C语言中的移位运算
- 左移：x << k, x向左移动k位，丢弃最高的k位，并在右端补k个0。[x<sub>w-k-1</sub>,...,x<sub>w-k-1</sub>,...,x<sub>0</sub>,0,...,0]
- 右移：x >> k：
- 逻辑右移：在左端补 k 个 0，[0,...,0,x<sub>w-1</sub>,x<sub>w-2</sub>,...,x<sub>k</sub>]
- 算术右移：在左端补 k 个最高有效位的值，[x<sub>w-1</sub>,...,x<sub>w-1</sub>,x<sub>w-1</sub>,x<sub>w-2</sub>,...,x<sub>k</sub>]

- 实际上，几乎所有的编译器/机器组合都对有符号数使用算术右移，且许多程序员也都假设机器会使用这种右移。
- 另一方面，对于无符号数，右移必须是逻辑的。
- Java中， x >> k ，是算术右移，x >>> k ，是逻辑右移。

## 2.2 整数表示
- 只能表示非负数
- 能够表示负数、零、正数
- 扩展或收缩一个已编码整数以适应不同长度表示

> 一些数学术语，精确定义和描述计算机如何编码和操作整数。（w表示位数）

| 符号 | 类型 | 含义 |
| :---: | :---: | :---: |
| B2T<sub>w</sub> | 函数 | 二进制转补码 |
| B2U<sub>w</sub> | 函数 | 二进制转无符号 |
| U2B<sub>w</sub> | 函数 | 无符号转二进制 |
| U2T<sub>w</sub> | 函数 | 无符号转补码 |
| T2B<sub>w</sub> | 函数 | 补码转二进制 |
| T2U<sub>w</sub> | 函数 | 补码转无符号 |
| TMin<sub>w</sub> | 常数 | 最小补码值 |
| TMax<sub>w</sub> | 常数 | 最大补码值 |
| UMax<sub>w</sub> | 常数 | 最大无符号数 |
| +<sup>t</sup><sub>w</sub> | 操作 | 补码加法 |
| +<sup>u</sup><sub>w</sub> | 操作 | 无符号加法 |
| *<sup>t</sup><sub>w</sub> | 操作 | 补码乘法 |
| *<sup>u</sup><sub>w</sub> | 操作 | 无符号乘法 |
| -<sup>t</sup><sub>w</sub> | 操作 | 补码取反 |
| -<sup>u</sup><sub>w</sub> | 操作 | 无符号取反 |

### 2.2.1 整型数据类型
- C语言标准定义了每种数据类型必须能够表示的最小的取值范围。
> C语言的整数数据类型的保证的取值范围

| C数据类型 | 最小值 | 最大值 |
| :---: | :---: | :---: |
| [signed]char | -127 | 127|
| unsigned char | 0 | 255 |
| short |  -32767 | 32767 |
| unsigned short | 0 | 65535 |
| int | -32767 | 32767 |
| unsigned int | 0 | 65535 |
| long | -2147 483 647 | 2147 483 647 |
| unsigned | 0 | 4294 967 295 |
| int32_t | -214748364 | 214748364 |
| uint32_t | 0 | 2147 483 647 |
| int64_t | -9223372036854775808 | 9223372036854775807 |
| uint64_t | 0 | 18446744073709551615 |

### 2.2.2 无符号数的编码
![](../../img/chapter-02/无符号数编码定义公式.gif)

> UMax<sub>w</sub> = ∑ 2<sup>i</sup> = 2<sup>w</sup> - 1

- 每个介于 0~2<sup>w</sup> - 1 之间的数都有唯一一个w位的值编码。 

- 函数B2U<sub>w</sub>是一个双射。反过来即是 U2B<sub>w</sub> ：在0~2<sup>w</sup> - 1之间的每一个整数都可以映射为一个唯一的长度为w的位模式

### 2.2.3 补码编码
- 最常见的有符号数的计算机表示方式就是补码形式。将字的最高有效位解释为负权。
- 补码定义：
> B2T<sub>w</sub> = -x<sub>w-1</sub>2<sup>w-1</sup> + ∑x<sub>i</sub>2<sup>i</sup>
- 最高有效位 x<sup>w-1</sup> 也成为符号位，权重为 -2<sup>w-1</sup>，是无符号表示中权重的负数。

<font color="red">*符号位被设置为1时，表示值为负，设置为0时，值为非负*</font>

- 补码编码的唯一性
- 函数 B2T<sub>w</sub> 是一个双射。反过来即是 T2B<sub>w</sub>

### 2.2.4 有符号数和无符号数之间的转换
- 多种可能
> 1、两种形式都能表示的值，想保持不变    
> 2、将负数转换成无符号数可能会得到 0     
> 3、如果转换的无符号数太大以至于超出了补码能表示的范围，可能会得到 T<sub>max</sub>

- C语言中，要从位级角度来看，不是从数的角度

```C
short int v = -12345;
unsigned short uv = (unsigned short)v;
printf("v = %d, uv = %u\n", v, uv);
```
得到输出：`v = -12345, uv = 53191`

```C
unsigned u = 4294967295u;
int tu = (int)u;
printf("u = %u, tu=%d\n", u, tu);
```
得到输出：`u = 4294967295u, tu = -1`

- 综合得出：处理同样字长的有符号数和无符号数之间相互转换的一般规则是：
> 数值可能会改变，但是位模式不变。

### 2.2.5 C语言中的有符号数与无符号数
- 一台采用补码的机器上，当从无符号数转换为有符号数时，效果就是应用函数U2T<sub>w</sub>，而从有符号数转换为无符号数时，就是应用函数T2U<sub>w</sub>。

### 2.2.6 扩展一个数字的位表示
- 要将一个无符号数转换为一个更大的数据类型，我们只要简单地在表示的开头添加0。这种运算被称为零扩展

### 2.2.7 截断数字
- 当将一个w位的数 x 向量 = [x<sub>w-1</sub>,x<sub>w-2</sub>,...,x<sub>0</sub>]阶段为一个k位数字时，我们会丢弃高 w - k位，得到一个位向量 x` = [x<sub>k-1</sub>,x<sub>k-2</sub>,...,x<sub>0</sub>]。

- 截断一个数字可能会改变它的值 —— 溢出的一种形式。

### 2.2.8 关于有符号数与无符号数的建议

## 2.3 整数运算
### 2.3.1 无符号加法

### 2.3.2 补码加法

### 2.3.3 补码的非
对于满足 TMin<sub>w</sub> <= x <= TMax<sub>w</sub>的x，其补码的非 -<sub>w</sub><sup>t</sup>x 由下式给出
![](../../img/chapter-02/补码的非.png)
*对于w位的补码加法来说，TMin<sub>w</sub>是自己的加法的逆，而对于其他任何数值，x都有-x作为其加法的逆。*

#### 练习题 2.33


### 2.3.4 无符号乘法

### 2.3.5 补码乘法

### 2.3.6 乘以常数

### 2.3.7 除以2的幂

### 2.3.8 关于整数运算的最后思考

## 2.4 浮点数
- 浮点表示对 形如 V = x * 2<sup>y</sup> 的有理数进行编码。对执行涉及非常大的数字(|V| >> 0)、非常接近于0(|V|<<1)的数字，以及更普遍地作为实数运算的近似值的计算，是很有用的。

### 2.4.1 二进制小数
- 十进制表示法：
> <b>d<sub>m</sub>d<sub>m-1</sub>...d<sub>1</sub>d<sub>0</sub>.d<sub>-1</sub>d<sub>-2</sub>...d<sub>-n</sub></b>

> d = ∑10<sup>i</sup> * d<sub>i</sub>(i = -n)

*小数点左边的数字的权是10的正幂，得到整数值，小数点右边的数字的权是10的负幂，得到小数值*
> 12.34<sub>10</sub> = 1 * 10<sup>1</sup> + 2 * 10<sup>0</sup> + 3 * 10<sup>-1</sup> + 4 * 10<sup>-2</sup>

- 类似的二进制表示：
> b = ∑2<sup>i</sup> * b<sub>i</sub>(i = -n)

*小数点是二进制小数点，小数点左边的数字的权是2的正幂，得到整数值，小数点右边的数字的权是2的负幂*
> 101.11<sub>2</sub> = 1 * 2<sup>2</sup> + 0 * 2<sup>1</sup> + 1 * 2<sup>0</sup> + 1 * 2<sup>-1</sup> + 1 * 2<sup>-2</sup>

***二进制小数点向左移动一位，相当于这个数被2除，向右移动一位相当于乘2***

- 二进制表示法只能表示那些能够被写成  x * 2<sup>y</sup> 的数。其他的值只能够被近似表示。
-增加二进制表示的长度可以提高表示的精度：

| 表示 | 值 | 十进制 |
| ---: | :---: | ---: |
| 0.0<sub>2</sub> | 0/2 | 0.0<sub>10</sub> |
| 0.01<sub>2</sub> | 1/4 | 0.25<sub>10</sub> |
| 0.010<sub>2</sub> | 2/8 | 0.25<sub>10</sub> |
| 0.0011<sub>2</sub> | 3/16 | 0.1875<sub>10</sub> |
| 0.00110<sub>2</sub> | 6/32 | 0.1875<sub>10</sub> |
| 0.001101<sub>2</sub> | 13/64 | 0.203125<sub>10</sub> |
| 0.0011010<sub>2</sub> | 26/128 | 0.203125<sub>10</sub> |
| 0.00110011<sub>2</sub> | 51/256 | 0.19921875<sub>10</sub> |

### 2.4.2 IEEE浮点表示
- IEEE浮点标准用 V = (-1)<sup>s</sup> * M * 2<sup>E</sup> 的形式来表示一个数 
    - 符号(sign) s决定正负，s=1是负数，s=0是正数。对于数值0的符号位解释作为特殊情况处理。
    - 尾数(significand) M是一个二进制小数，范围是1 ~ 2-e，或者是0 ~ 1-e。
    - 阶码(exponent) E的作用是对浮点数甲醛，权重是2的E次幂(可能是负数)
- 将浮点数的位表示划分为三个字段，分别对这些值进行编码：
    - 一个单独的符号位s直接编码符号s
    - k位的阶码字段 exp = e<sub>k-1</sub>...e<sub>1</sub>e<sub>0</sub>
    - n位小数字段 frac = f<sub>n-1</sub>...f<sub>1</sub>f<sub>0</sub> 编码尾数M，但是编码出来的值也依赖于阶码字段的值是否等于0

### 2.4.3 数字示例
### 2.4.4 舍入
- IEEE 浮点格式定义了四种不同的舍入方式。默认方法是找到最接近的匹配，其他三种可用于计算上下界。
>向偶数舍入方式采用的是：将数字向上或者向下舍入，舍得结果的最低有效数字时偶数。

| 方式 | 1.40 | 1.60 | 1.50 | 2.50 | -1.50 |
| :---: | :---: | :---: | :---: | :---: | :---: |
| 向偶数舍入 | 1 | 2 | 2 | 2 | -2 |
| 向零舍入 | 1 | 1 | 1 | 2 | -1 |
| 向下舍入 | 1 | 1 | 1 | 2 | -2 |
| 向上舍入 | 2 | 2 | 2 | 3 | -1 |

### 2.4.5 浮点运算
### 2.4.6 C语言中的浮点数

## 2.5 小结
- 计算机将信息编码为位(比特)，通常组织成字节序列。有不同的编码方式用来表示整数、实数和字符串。
- 大多数机器对整数使用补码编码，而对浮点数使用IEEE标准754编码。

