## 1.1 信息就是位+上下文

一个源程序 [hello.c](../../code/intro/hello.c)

- 1个字节 = 8位

- ASCII 用一个唯一的 *单字节* 大小的整数值表示 *每个* 字符
- 系统中的所有的信息————包括磁盘文件、存储器中的程序、存储器中存放的用户数据以及网络上传送的数据，都是由 *一串位* 表示
- 区分不同数据对象的方式，是读到这些数据对象时的上下文。在不同的上下文中，一个相同的位序列可以表示不同的内容，或者是整数、浮点数、字符串或者机器指令
- 文本文件和二进制文件
    > 只有ASCII字符构成的文件称为文本文件，其他所有文件都称为二进制文件

## 1.2 程序被其他程序翻译成不同的格式

- hello 程序编译过程
    > 每条C语句都必须被其他程序转化为一系列的低级机器语言指令。
    > 这些指令按照 *可执行目标程序* 格式打包，并以二进制形式存放

- Unix系统上的编译：
    - `gcc -o hello hello.c`
- 编译系统
    - 预处理器、编译器、汇编器、链接器

![](../../img/chapter-01/编译系统.png)

- 预处理阶段(cpp)
    > 根据以字符 # 开头的命令，修改原始的 C 程序，得到另一个C程序，通常使用 i 作为文件扩展名

- 编译阶段(ccl)
    > 将文本 hello.i 翻译成 hello.s，包含一个汇编语言程序
    > 每一条汇编语句都以一种标准的文本格式确切地描述了一条低级语言指令。
    > 汇编语言为不同的高级语言的不同编译器提供了通用的输出语言

- 汇编阶段(as)
    > 汇编器将 hello.s 翻译成机器语言指令，将指令按照 可重定位目标程序 的格式保存在 hello.o 二进制文件中
- 链接阶段(ld)
    > hello程序调用了printf函数，是标准C库中的一个函数，存在于一个名为 printf.o 的单独预编译好的目标文件中，链接器负责将这种文件以某种方式合并到hello.o文件中。结果得到hello文件，是一个可执行目标文件
    > 目标文件可以被加载到内存中，由系统执行

## 1.3 了解编译系统如何工作是大有益处的
- 优化程序性能
    - switch是否总比if-then-else高效？
    - 一个函数调用的开销有多大？
    - while比for更有效吗？
    - 指针引用比数组索引更有效吗？
    - 为什么将循环求和的结果放到一个本地变量中，与将其放到一个通过引用传递过来的参数中相比，运行速度快很多？
    - 为什么我们只是简单重新排列一下一个算术表达式中的括号就能让一个函数运行的更快？
    
- 理解链接时出现的错误
    - 链接器报告它无法解析一个引用时什么意思？
    - 静态变量和全局变量的区别是什么？
    - 静态库和动态库的区别是什么？
    - 在命令行上排列库的顺序有什么影响？
    - 为什么有些链接错误直到运行时才会出现？
- 避免安全漏洞
    - 理解数据和控制信息存储在程序栈上的方式会引起的后果。