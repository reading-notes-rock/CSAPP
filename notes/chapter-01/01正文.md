[toc]

## 1.1 信息就是位+上下文

一个源程序 [hello.c](../../code/intro/hello.c)

- 1个字节 = 8位

- ASCII 用一个唯一的 *单字节* 大小的整数值表示 *每个* 字符
- 系统中的所有的信息————包括磁盘文件、存储器中的程序、存储器中存放的用户数据以及网络上传送的数据，都是由 *一串位* 表示
- 区分不同数据对象的方式，是读到这些数据对象时的上下文。在不同的上下文中，一个相同的位序列可以表示不同的内容，或者是整数、浮点数、字符串或者机器指令
- 文本文件和二进制文件
    > 只有ASCII字符构成的文件称为文本文件，其他所有文件都称为二进制文件

## 1.2 程序被其他程序翻译成不同的格式

- hello 程序编译过程
    > 每条C语句都必须被其他程序转化为一系列的低级机器语言指令。
    > 这些指令按照 *可执行目标程序* 格式打包，并以二进制形式存放

- Unix系统上的编译：
    - `gcc -o hello hello.c`
- 编译系统
    - 预处理器、编译器、汇编器、链接器

![](../../img/chapter-01/编译系统.png)

- 预处理阶段(cpp)
    > 根据以字符 # 开头的命令，修改原始的 C 程序，得到另一个C程序，通常使用 i 作为文件扩展名

- 编译阶段(ccl)
    > 将文本 hello.i 翻译成 hello.s，包含一个汇编语言程序
    > 每一条汇编语句都以一种标准的文本格式确切地描述了一条低级语言指令。
    > 汇编语言为不同的高级语言的不同编译器提供了通用的输出语言

- 汇编阶段(as)
    > 汇编器将 hello.s 翻译成机器语言指令，将指令按照 可重定位目标程序 的格式保存在 hello.o 二进制文件中
- 链接阶段(ld)
    > hello程序调用了printf函数，是标准C库中的一个函数，存在于一个名为 printf.o 的单独预编译好的目标文件中，链接器负责将这种文件以某种方式合并到hello.o文件中。结果得到hello文件，是一个可执行目标文件
    > 目标文件可以被加载到内存中，由系统执行

## 1.3 了解编译系统如何工作是大有益处的
- 优化程序性能
    - switch是否总比if-then-else高效？
    - 一个函数调用的开销有多大？
    - while比for更有效吗？
    - 指针引用比数组索引更有效吗？
    - 为什么将循环求和的结果放到一个本地变量中，与将其放到一个通过引用传递过来的参数中相比，运行速度快很多？
    - 为什么我们只是简单重新排列一下一个算术表达式中的括号就能让一个函数运行的更快？
    
- 理解链接时出现的错误
    - 链接器报告它无法解析一个引用时什么意思？
    - 静态变量和全局变量的区别是什么？
    - 静态库和动态库的区别是什么？
    - 在命令行上排列库的顺序有什么影响？
    - 为什么有些链接错误直到运行时才会出现？
- 避免安全漏洞
    - 理解数据和控制信息存储在程序栈上的方式会引起的后果。

## 1.4 处理器读并解释储存在内存中的指令
- 在shell中，如果命令行的第一个单词不是内置的shell命令，那么shell就会假设这是一个可执行文件的名字。它将加载并运行这个文件

    ### 1.4.1 系统的硬件组成
    *一个典型系统的硬件组成*
    ![一个典型系统的硬件组成](../../img/chapter-01/典型系统的硬件组成.png)
    _CPU:中央处理单元；ALU:算术/逻辑单元;PC:程序计数器；USB: 通用串行总线_
    - 总线
        > 贯穿整个系统的一组电子管道
        
        > 在各个部件间传递信息字节

        > 通常传送定长的字节快，也就是 字 (word)
        
        > 字中的字节数 叫 字长
        
        > 32位机一个字长为4个字节（4\*8位），64位机一个字长为8个字节（8\*8位）
    - I/O设备
        > 系统与外界的联系通道，比如键鼠、显示器、磁盘

        > 每个I/O设备通过一个控制器或适配器与I/O总线相连
                
                适配器和控制器的区别：
                封装方式不同
                    控制器是I/O设备本身或者系统的主板上的芯片组
                    适配器是一块插在主板插槽上的卡
    - 主存储器
        > 一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。

        > 物理：由一组 *动态随机存取存储器(DRAM)* 芯片组成

        > 逻辑：一个线性的字节数组，每个字节都有唯一的地址，从零开始
    - 处理器(CPU)
        > 解释（或执行）存储在主存中指令的 *引擎*

        > 核心是一个大小为一个字的存储设备(或寄存器),称为程序计数器(PC),在任何时候，PC都指向主存中的某条机器语言指令(即含有该条指令的地址)。
        
        > 从系统通电到断电，处理器一直不断地执行程序计数器指向的指令，再更新程序计数器，使其指向下一条指令。

        > 处理器 看上去是按照一个非常简单的指令执行模型来操作的，这个模型是由指令集架构决定的。

        > 在这个模型中，指令按照严格的顺序执行，而执行一条指令包括执行一系列的步骤。

        > 处理器从程序计数器指向的内存处读取指令，解释指令中的位，执行该指令的简单操作，然后更新PC，使其指向下一条指令，而这条指令并不一定和在内存中刚刚执行的指令相邻。
               
        - 加载：从主存复制一个字节或者一个字到寄存器，覆盖寄存器原来的内容。
        - 存储：从寄存器复制一个字节或者一个字到主存的某个位置，覆盖这个位置原来的内容。
        - 操作：把两个寄存器的内容复制到ALU，ALU对这两个字做算术运算，并将结果存放到一个寄存器中，覆盖该寄存器原来的内容。
        - 跳转：从指令本身中抽取一个字，并将这个字复制到PC中，覆盖PC中原来的值。

    ### 1.4.2 运行hello程序
        `$ ./hello`
        shell程序将字符逐一读入寄存器，再放到内存中
        回车
        shell知道我们结束了命令的输入,执行一系列指令，加载可执行的hello文件（从磁盘到主存）, 包括最终会被输出的字符串"hello,world\n"
        hello文件中的代码和数据被加载到主存，处理器就开始执行hello程序的main程序中的机器语言指令。
        将 "hello, world\n"字符串中的字节从主存复制到寄存器
        再从寄存器文件中复制到显示设备

